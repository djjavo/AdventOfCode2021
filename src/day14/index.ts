export const parseInput = (input: string[]) => {
  const polymerTemplate = input[0];

  // generate a map of pairs to the new pairs they create
  const pairInsertionRules: Record<string, string[]> = {};
  for (const line of input.slice(2)) {
    const [a, b] = line.split(' -> ');
    pairInsertionRules[a] = [`${a[0]}${b}`, `${b}${a[1]}`];
  }

  // generate the initial count of pairs by interating through each 2 character substring
  const pairCounts: Record<string, number> = {};
  for (let i = 0; i < polymerTemplate.length - 1; i++) {
    pairCounts[polymerTemplate.substring(i, i + 2)] =
      (pairCounts[polymerTemplate.substring(i, i + 2)] || 0) + 1;
  }

  return {
    polymerTemplate,
    pairCounts,
    pairInsertionRules
  };
};

export const processStep = (
  pairCounts: Record<string, number>,
  pairInsertionRules: Record<string, string[]>
) => {
  const updatedPairCounts: Record<string, number> = { ...pairCounts };

  // for each pair, increment the pairs generated by the number of specific pairs at the start of the step
  // then decrement the count of all of specific pairs (as they no longer exist)
  for (const pair of Object.keys(pairCounts)) {
    updatedPairCounts[pairInsertionRules[pair][0]] =
      (updatedPairCounts[pairInsertionRules[pair][0]] || 0) + pairCounts[pair];

    updatedPairCounts[pairInsertionRules[pair][1]] =
      (updatedPairCounts[pairInsertionRules[pair][1]] || 0) + pairCounts[pair];

    updatedPairCounts[pair] = updatedPairCounts[pair] - pairCounts[pair] || 0;
  }

  return updatedPairCounts;
};

export const calculateElementRange = (
  input: string[],
  numberOfSteps: number
) => {
  const { polymerTemplate, pairCounts, pairInsertionRules } = parseInput(input);

  let updatedPairCounts = { ...pairCounts };

  for (let i = 0; i < numberOfSteps; i++) {
    updatedPairCounts = processStep(updatedPairCounts, pairInsertionRules);
  }

  const counts: Record<string, number> = {};

  for (const [pair, pairCount] of Object.entries(updatedPairCounts)) {
    counts[pair[0]] = (counts[pair[0]] || 0) + pairCount;
    counts[pair[1]] = (counts[pair[1]] || 0) + pairCount;
  }

  // increment the first and last character by 1
  counts[polymerTemplate[0]] += 1;
  counts[polymerTemplate.substring(polymerTemplate.length - 1)] += 1;

  // divide by 2 as each letter is counted twice
  const numCounts = Object.values(counts).map(count => count / 2);

  return Math.max(...numCounts) - Math.min(...numCounts);
};

const part1 = (input: string[]) => calculateElementRange(input, 10);

const part2 = (input: string[]) => calculateElementRange(input, 40);

export default { part1, part2 };
